#!/usr/bin/env python3
from pyroute2 import IPRoute
import subprocess
import logging
import os
import datetime
import sync.eos.MfwEapiClientLib as EapiClientLib
import json

INTF_OPER_UP = 1
INTF_OPER_DOWN = 2
INTF_LINK_UP = 2
INTF_LINK_DOWN = 1
BASH_TIMEOUT = 15

class NetlinkHandler:
    def __init__(self):
        self.sysdb_path = "/ar/Sysdb/interface/status/eth/phy/all/intfStatus"
        self.ipr = IPRoute()
        self.ipr.bind()

        # Set up logging
        self.log_dir = "/var"
        self.log_file = os.path.join(self.log_dir, f"intf_status{datetime.datetime.now().strftime('%Y%m%d%H%M%S')}.log")
        self.logger = self.setup_logger()

        self.interface_list = []

        self.eapiClient = EapiClientLib.EapiClient('ar', disableAaa=True, privLevel=15)

        self.get_interface_names() # update the list of interfaces from sfaFruFile
        self.init()  # Call the initialization method

    def setup_logger(self):
        logger = logging.getLogger("NetlinkHandler")
        logger.setLevel(logging.DEBUG)

        formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")

        file_handler = logging.FileHandler(self.log_file)
        file_handler.setLevel(logging.DEBUG)
        file_handler.setFormatter(formatter)

        logger.addHandler(file_handler)

        return logger

    def get_interface_names(self):
        sfaFruFile = "/var/run/sfaFruPluginDevices.json"
        output = self.eapiClient.runCmds(version=1,cmds=[ f"bash  timeout {BASH_TIMEOUT} cat {sfaFruFile} " ],format="text", requestTimeout=1 )
        if(output != None):
            devices = json.loads(output['result'][0]['output'])
            self.interface_list = devices['device']
        else:
            self.logger.info(f"No devices found from {sfaFruFile} exiting....")
            exit()

    def get_link_status(self, interface):
        ifname = None
        operstate = None

        for attribute, value in interface['attrs']:
            if attribute == 'IFLA_IFNAME':
                ifname = value
            elif attribute == 'IFLA_OPERSTATE':
                operstate = value

        return ifname, operstate

    def handle_netlink_message(self, ifname, status):

        if(ifname not in self.interface_list):
            return

        # Sysdb uses "Ethernet" as naming convention
        intf_name = ifname.replace("et","Ethernet")

        # if "_" in interface name, need to add '\' in the sysdb path
        if("_" in intf_name):
            pre,post = intf_name.split("_")
            intf_name = f"""{pre}\/{post}"""

        sysdb_intf_path = f"{self.sysdb_path}/{intf_name}"

        if status == "DOWN":
            self.logger.info(f"Interface {ifname} is down.")
            operstatus = INTF_OPER_DOWN
            linkstatus = INTF_LINK_DOWN
        else:
            self.logger.info(f"Interface {ifname} is up.")
            operstatus = INTF_OPER_UP
            linkstatus = INTF_LINK_UP

        command = f'(echo -e "cd {sysdb_intf_path}"; echo -e "_.operStatus={operstatus}"; echo -e "_.linkStatus={linkstatus}") | python3 -m Acons Sysdb'
        timeout_cmd = f"timeout {BASH_TIMEOUT} bash -c"

        result = self.eapiClient.runCmds(version=1,cmds=[ f"bash  {timeout_cmd} '{command}' " ],format="text", requestTimeout=1 )
        if("Error" in result):
            self.logger.error(f"Failed to run {command}")

    def init(self):
        interfaces = self.ipr.get_links()
        for interface in interfaces:
            ifname, status = self.get_link_status(interface)
            if ifname in self.interface_list:
                self.handle_netlink_message(ifname, status)
        self.logger.error(f"Initial Sync Up Done...")

    def run(self):
        interface_states = {}
        self.logger.info(f"Starting to poll for RTM_NEWLINK Messages")
        while True:
            msgs = self.ipr.get()
            for msg in msgs:
                if msg['event'] == "RTM_NEWLINK":
                    ifname = None
                    operstate = None

                    for attribute, value in msg['attrs']:
                        if attribute == 'IFLA_IFNAME':
                            ifname = value
                        elif attribute == 'IFLA_OPERSTATE':
                            operstate = value

                    if ifname and operstate:
                        interface_states[ifname] = operstate

            if interface_states:
                interfaces_down = [ifname for ifname, state in interface_states.items() if state == 'DOWN']
                interfaces_up = [ifname for ifname, state in interface_states.items() if state == 'UP']

                if interfaces_down:
                    self.logger.info("Interfaces that are down: %s", ",".join(interfaces_down))
                    for ifname in interfaces_down:
                        self.handle_netlink_message(ifname, "DOWN")

                if interfaces_up:
                    self.logger.info("Interfaces that are up: %s", ",".join(interfaces_up))
                    for ifname in interfaces_up:
                        self.handle_netlink_message(ifname, "UP")

            interface_states = {}

#instanitate the Netlinkhandler
handler = NetlinkHandler()
handler.run()
