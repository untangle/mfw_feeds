#!/usr/bin/env python3
from pyroute2 import IPRoute
import subprocess
import logging
import os
import datetime
import sync.eos.MfwEapiClientLib as EapiClientLib
import json
import subprocess

INTF_OPER_UP = 1
INTF_OPER_DOWN = 2
INTF_LINK_UP = 2
INTF_LINK_DOWN = 1
BASH_TIMEOUT = 15

class NetlinkHandler:
    def __init__(self):
        self.sysdb_path = "/ar/Sysdb/interface/status/eth/phy/all/intfStatus"
        self.subintf_sysdb_path = "/ar/Sysdb/interface/status/subintf/intfStatus"
        self.ipr = IPRoute()
        self.ipr.bind()

        self.interface_list = []

        self.eapiClient = EapiClientLib.EapiClient('ar', disableAaa=True, privLevel=15)

        self.get_interface_names() # update the list of interfaces from sfaFruFile
        self.init()  # Call the initialization method

    def get_interface_names(self):
        sfaFruFile = "/var/run/sfaFruPluginDevices.json"
        output = self.eapiClient.runCmds(version=1,cmds=[ f"bash  timeout {BASH_TIMEOUT} cat {sfaFruFile} " ],format="text", requestTimeout=1 )
        try:
            if(output != None):
                    devices = json.loads(output['result'][0]['output'])
                    self.interface_list = devices['device']
            else:
                raise ValueError(f"No devices found from {sfaFruFile}.")

        except (ValueError, json.JSONDecodeError, TypeError) as e:
            print("An error occurred while parsing the JSON:", e)
            exit()

    def get_link_status(self, interface):
        ifname = None
        operstate = None

        for attribute, value in interface['attrs']:
            if attribute == 'IFLA_IFNAME':
                ifname = value
            elif attribute == 'IFLA_OPERSTATE':
                operstate = value

        return ifname, operstate

    def handle_netlink_message(self, ifname, status):

        subintf_admin_state = False
        subint_ip_add = 0
        valid_ifname = ifname

        # For subinterfaces grep the physcial interface details to check if the interface is valid
        if("." in ifname):
            pi = ifname.split(".")[0]
            valid_ifname = pi

        # check if the interface belongs to valid list of interfaces
        if(valid_ifname not in self.interface_list):
            return

        # Sysdb uses "Ethernet" as naming convention
        intf_name = ifname.replace("et","Ethernet")

        # if "_" in interface name, need to add '\' in the sysdb path
        if("_" in intf_name):
            pre,post = intf_name.split("_")
            intf_name = f"""{pre}\/{post}"""

        # if the interface is valid grep the admin state of the subinterface
        # and update the sysdb_intf_path for physical or vlan interface
        if ("." in ifname):
            setting_file = "/mnt/flash/mfw-settings/settings.json"
            output = self.eapiClient.runCmds(version=1,cmds=[ f"bash  timeout {BASH_TIMEOUT} cat {setting_file} " ],format="text", requestTimeout=5 )
            if(output != None):
                data = json.loads(output['result'][0]['output'])
            for item in data["network"]["interfaces"]:
                # check if the physical interface is enabled
                if item["device"] == pi:
                    pi_admin_state = item["enabled"]
                # check if the created vlan interface is enabled in settings.json
                if item["device"] == ifname:
                    subintf_admin_state = item["enabled"]
                    subint_ip_add = item["v4StaticAddress"]
            # update the sysdb subintf path
            sysdb_intf_path = f"{self.subintf_sysdb_path}/{intf_name}"
        
        else:
            sysdb_intf_path = f"{self.sysdb_path}/{intf_name}"

        if status == "DOWN":
            print(f"Interface {ifname} is down.")
            operstatus = INTF_OPER_DOWN
            linkstatus = INTF_LINK_DOWN
        else:
            print(f"Interface {ifname} is up.")
            operstatus = INTF_OPER_UP
            linkstatus = INTF_LINK_UP

        # if its a sub interface, check the admin state and physical interface state
        # to bring it up manually
        if ( "." in ifname):
            if(subintf_admin_state and pi_admin_state):
                command = f'(echo -e "cd /ar/Sysdb/interface/hardware/status/subintf"; echo -e "_.hardwareStatus.newMember{intf_name}") | python3 -m Acons Sysdb'
                cmd = f"ifconfig  {ifname} {subint_ip_add} up"
            else:
                cmd = f"ifconfig {ifname} down"

            try:
                subprocess.check_output(cmd, shell=True, text=True)
            except subprocess.CalledProcessError as e:
                print("Command execution failed with error:", e)

        command = f'(echo -e "cd {sysdb_intf_path}"; echo -e "_.operStatus={operstatus}"; echo -e "_.linkStatus={linkstatus}") | python3 -m Acons Sysdb'

        timeout_cmd = f"timeout {BASH_TIMEOUT} bash -c"

        result = self.eapiClient.runCmds(version=1,cmds=[ f"bash  {timeout_cmd} '{command}' " ],format="text", requestTimeout=1 )
        if("Error" in result):
            print(f"Failed to run {command}")

    def init(self):
        interfaces = self.ipr.get_links()
        for interface in interfaces:
            ifname, status = self.get_link_status(interface)
            # grep the physical interface name if it is a subinterface
            if ("." in ifname):
                ifname = ifname.split(".")[0]

            if ifname in self.interface_list:
                self.handle_netlink_message(ifname, status)

        print(f"Initial Sync Up Done...")

    def run(self):
        interface_states = {}
        print(f"Starting to poll for RTM_NEWLINK Messages")
        while True:
            msgs = self.ipr.get()
            for msg in msgs:
                if msg['event'] == "RTM_NEWLINK":
                    ifname = None
                    operstate = None

                    for attribute, value in msg['attrs']:
                        if attribute == 'IFLA_IFNAME':
                            ifname = value
                        elif attribute == 'IFLA_OPERSTATE':
                            operstate = value

                    if ifname and operstate:
                        interface_states[ifname] = operstate

            if interface_states:
                for ifname,state in interface_states.items():
                    self.handle_netlink_message(ifname, state)

            interface_states = {}

#instanitate the Netlinkhandler
handler = NetlinkHandler()
handler.run()
