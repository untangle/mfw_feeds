#!/usr/bin/env python3
from pyroute2 import IPRoute
import subprocess
import logging
import os
import datetime
import sync.eos.MfwEapiClientLib as EapiClientLib
import json
import subprocess

INTF_OPER_UP = 1
INTF_OPER_DOWN = 2
INTF_LINK_UP = 2
INTF_LINK_DOWN = 1
BASH_TIMEOUT = 15

class NetlinkHandler:
    def __init__(self):
        self.sysdb_path = "/ar/Sysdb/interface/status/eth/phy/all/intfStatus"
        self.subintf_sysdb_path = "/ar/Sysdb/interface/status/subintf/intfStatus"
        self.timeout_cmd = f"timeout {BASH_TIMEOUT} bash -c"
        self.ipr = IPRoute()
        self.ipr.bind()

        self.interface_list = []

        self.eapiClient = EapiClientLib.EapiClient('ar', disableAaa=True, privLevel=15)

        self.get_interface_names() # update the list of interfaces from sfaFruFile
        self.init()  # Call the initialization method

    def get_interface_names(self):
        sfaFruFile = "/var/run/sfaFruPluginDevices.json"
        output = self.eapiClient.runCmds(version=1,cmds=[ f"bash  timeout {BASH_TIMEOUT} cat {sfaFruFile} " ],format="text", requestTimeout=1 )
        try:
            if(output != None):
                    devices = json.loads(output['result'][0]['output'])
                    self.interface_list = devices['device']
            else:
                raise ValueError(f"No devices found from {sfaFruFile}.")

        except (ValueError, json.JSONDecodeError, TypeError) as e:
            print("An error occurred while parsing the JSON:", e)
            exit()

    def get_link_status(self, interface):
        ifname = None
        operstate = None

        for attribute, value in interface['attrs']:
            if attribute == 'IFLA_IFNAME':
                ifname = value
            elif attribute == 'IFLA_OPERSTATE':
                operstate = value

        return ifname, operstate


    # if the interface is valid grep the admin state of the subinterface
    # and update the sysdb_intf_path for physical or vlan interface
    def handle_sub_intf_netlink_message(self, ifname, intf_name):

        sysdb_intf_path = f"{self.subintf_sysdb_path}/{intf_name}"
        subintf_admin_state = False
        subint_ip_add = 0

        pi = ifname.split(".")[0]
        setting_file = "/etc/config/settings.json"
        try:
            cmd = f"cat {setting_file}"
            output = subprocess.check_output(cmd, shell=True, text=True)

        except subprocess.CalledProcessError as e:
            print("Command execution failed with error:", e)

        try:
            if(output != None):
                    data = json.loads(output)
                    for item in data["network"]["interfaces"]:
                        # check if the physical interface is enabled
                        if item["device"] == pi:
                            pi_admin_state = item["enabled"]
                        # check if the created vlan interface is enabled in settings.json
                        if item["device"] == ifname:
                            subintf_admin_state = item["enabled"]
                            subint_ip_add = item["v4StaticAddress"]
            else:
                raise ValueError(f"No data found in {setting_file}.")

        except (ValueError, json.JSONDecodeError, TypeError) as e:
            print(f"An error occurred while parsing the JSON for {ifname}:", e)

        if(subintf_admin_state and pi_admin_state):
            command = f'(echo -e "cd /ar/Sysdb/interface/hardware/status/subintf"; echo -e "_.hardwareStatus.newMember{intf_name}") | python3 -m Acons Sysdb'
            result = self.eapiClient.runCmds(version=1,cmds=[ f"bash  {self.timeout_cmd} '{command}' " ],format="text", requestTimeout=1 )
            if("Error" in result):
                print(f"Failed to run {command}")
            cmd = f"ifconfig  {ifname} {subint_ip_add} up"
        else:
            cmd = f"ifconfig {ifname} down"

        try:
            subprocess.check_output(cmd, shell=True, text=True)
        except subprocess.CalledProcessError as e:
            print("Command execution failed with error:", e)

        return sysdb_intf_path

    def handle_netlink_message(self, ifname, status):
        print(f"ifname is {ifname}")
        # Sysdb uses "Ethernet" as naming convention
        intf_name = ifname.replace("et","Ethernet")

        # if "_" in interface name, need to add '\' in the sysdb path
        if("_" in intf_name):
            pre,post = intf_name.split("_")
            intf_name = f"""{pre}\/{post}"""

        # if its sub interface call handle_sub_intf_netlink_message
        if ("." in ifname):
            sysdb_intf_path = self.handle_sub_intf_netlink_message(ifname, intf_name)

        else:
            sysdb_intf_path = f"{self.sysdb_path}/{intf_name}"

        if status == "DOWN":
            print(f"Interface {ifname} is down.")
            operstatus = INTF_OPER_DOWN
            linkstatus = INTF_LINK_DOWN
        else:
            print(f"Interface {ifname} is up.")
            operstatus = INTF_OPER_UP
            linkstatus = INTF_LINK_UP

        command = f'(echo -e "cd {sysdb_intf_path}"; echo -e "_.operStatus={operstatus}"; echo -e "_.linkStatus={linkstatus}") | python3 -m Acons Sysdb'

        result = self.eapiClient.runCmds(version=1,cmds=[ f"bash  {self.timeout_cmd} '{command}' " ],format="text", requestTimeout=1 )
        if("Error" in result):
            print(f"Failed to run {command}")

    def init(self):
        interfaces = self.ipr.get_links()
        for interface in interfaces:
            ifname, status = self.get_link_status(interface)
            original_ifname = ifname
            # grep the physical interface name if it is a subinterface
            if ("." in ifname):
                ifname = ifname.split(".")[0]

            if ifname in self.interface_list:
                self.handle_netlink_message(original_ifname, status)

        print(f"Initial Sync Up Done...")

    def run(self):
        interface_states = {}
        print(f"Starting to poll for RTM_NEWLINK Messages")
        while True:
            msgs = self.ipr.get()
            for msg in msgs:
                if msg['event'] == "RTM_NEWLINK":
                    ifname = None
                    operstate = None

                    for attribute, value in msg['attrs']:
                        if attribute == 'IFLA_IFNAME':
                            ifname = value
                        elif attribute == 'IFLA_OPERSTATE':
                            operstate = value

                    if ifname and operstate:
                        interface_states[ifname] = operstate

            if interface_states:
                for ifname,state in interface_states.items():
                    original_ifname = ifname
                    if ("." in ifname):
                        ifname = ifname.split(".")[0]
                    if ifname in self.interface_list:
                        self.handle_netlink_message(original_ifname, state)

            interface_states = {}

#instanitate the Netlinkhandler
handler = NetlinkHandler()
handler.run()
