#!/bin/sh
##
## Include libraries
##
. /lib/functions/network.sh
. /usr/share/libubox/jshn.sh

##
## Global variables
##
## Calling name
COMMAND_NAME=$0
# Our pid
COMMAND_PID=$$
# Debug mode for messages and other output
DEBUG=false
# If true, run in interative mode, otherwise in dameon mode.
INTERACTIVE=false
# If non empty, log debug messages that match substring.  Commonly used to watch substring.
LOG_WATCH=

## Utility-specific variables
# In this interval, allow status messages to be logged.
ALLOW_LOG_UPDATE_INTERVAL=60 
# Root path for wan status tree
WAN_MANAGER_STATUS_PATH=/tmp/wan_status

##
## Process command line arguments
##
while getopts "d:i:l:v:" flag; do
    case "${flag}" in
        d) DEBUG=${OPTARG} ;;
        i) INTERACTIVE=${OPTARG} ;;
        l) LOG_WATCH=${OPTARG} ;;
        v) eval "${OPTARG}" ;;
    esac
done
shift $((OPTIND-1))

##
## Utilities
##

# Always log messages of this priority
LOG_MESSAGE_PRIORITY_ANY=0
# Only log messages if DEBUG=true
LOG_MESSAGE_PRIORITY_DEBUG=1
if [ "$INTERACTIVE" = "true" ] ; then
	# In interactive mode use echo
	LOGGER_COMMAND="echo"
	LOGGER_TIMESTAMP=date
else
	# LOGGER_COMMAND="logger -t wan-manager"
	LOGGER_COMMAND="logger -t wan-manager"
	LOGGER_TIMESTAMP=
fi

# log_message
# Log a message to specified LOGGER_COMMAND
#
# @param $1    Priority (see above)
# @param $2    Message
log_message()
{
	local __function_name="log_message"
	local priority=$1
	local message=$2

	if [ $priority = $LOG_MESSAGE_PRIORITY_DEBUG ] ; then
		if [ "$DEBUG" = true ]; then
			# Only log if DEBUG is enabled
			$LOGGER_COMMAND $(eval $LOGGER_TIMESTAMP) "debug  $message"
		fi
		if [ "$LOG_WATCH" != "" ] && [ -z "${message##*$LOG_WATCH*}" ]; then
			# Message matches logwatchOnly log if DEBUG is enabled
			$LOGGER_COMMAND $(eval $LOGGER_TIMESTAMP) "debug  $message"
		fi
	elif [ $priority = $LOG_MESSAGE_PRIORITY_ANY ]; then
		# Always log these messages
		if [ "$DEBUG" = true ] || [ "$LOG_WATCH" != "" ] ; then
			# In interactive mode, provide space separation from debug prefix.
			$LOGGER_COMMAND $(eval $LOGGER_TIMESTAMP) "any    $message"
		else
			$LOGGER_COMMAND $(eval $LOGGER_TIMESTAMP) "$message"
		fi
	fi
}

# log_status_message
# Log a status message with debug and any priorities
#
# @param $1    State which can be "change" or "status".
# @param $2    Prefix for the message, typically the function name.
# @param $3    Changed message, usually reflecting transitions like "status=up->down"
# @param $4    Stats message with fields like "status=up"
# @param $5    Extra information to log in debug or watch mode
log_status_message(){
	local state=$1
	local prefix=$2
	local change_message=$3
	local status_message=$4
	local debug_append_message=$5

	local __message

	local log_watch=false
	if [ "$LOG_WATCH" != "" ] && [ -z "${prefix##*$LOG_WATCH*}" ]; then
		log_watch=true
	fi

	if [ "$state" = "change" ] ; then
		__message=$change_message
		if [ "$DEBUG" = "true" ] || [ "$log_watch" = "true" ]; then
			__message="$__message $debug_append_message"
		fi
		log_message $LOG_MESSAGE_PRIORITY_ANY "$prefix state=$state, $__message"
	else
		__message=$status_message
		if [ "$DEBUG" = "true" ] || [ "$log_watch" = "true" ]; then
			__message="$__message $debug_append_message"
		fi
		if [ "$DEBUG" == "true" ] || [ "$ALLOW_LOG_UPDATE" == "true" ]; then
			log_message $LOG_MESSAGE_PRIORITY_ANY "$prefix state=$state, $__message"
		fi
	fi

}

# Allow initial status first time in
ALLOW_LOG_UPDATE=true
ALLOW_LOG_UPDATE_START=$(date +%s)
# check_allow_log_update
# Check for $ALLOW_LOG_UPDATE_INTERVAL if reached, set $ALLOW_LOG_UPDATE to true,
# allowing those who wish to log at this interval to do so.
# 
# This is used to:
# - Log policy status period regardless of change 
# - Log policy status for polices that otherwise log a lot like balance.
check_allow_log_update()
{
	local __function_nane="check_allow_log_update"
	local currentTime=$(date +%s)
	local elapsedTime=$((currentTime - $ALLOW_LOG_UPDATE_START))
	if [ $elapsedTime -gt $ALLOW_LOG_UPDATE_INTERVAL ]; then
		ALLOW_LOG_UPDATE_START=$(date +%s)
		ALLOW_LOG_UPDATE=true
	else
		ALLOW_LOG_UPDATE=false
	fi
}

# get_policy_path
# Retrieve the path for the specified policy.
#
# @param $1           Path variable to update.
# @param $policyId    Policy id
get_policy_path(){
	local __function_name="get_policy_path"
	local __return_path=$1
	local policyId=$2

	local path=$WAN_MANAGER_STATUS_PATH/$policyId
	if [ ! -d $path ] ; then
		mkdir -p $path
	fi

	eval "$__return_path=$path"
}

# get_wan_path
# Retrieve the path for the WAN under the specified policy.
#
# @param $1           Path variable to update.
# @param $policyId    Policy id
# @param $policyId    WAN interface id
get_wan_path(){
	local __function_name="get_wan_path"
	local __return_path=$1
	local policyId=$2
	local interfaceId=$3
	local family=$4

	local policyPath
	get_policy_path policyPath $policyId

	local path=$policyPath/wan-$interfaceId/$family
	if [ ! -d $path ] ; then
		mkdir -p $path
	fi

	eval "$__return_path=$path"
}

# check_for_table
# Verifies requried nft tables to exists
#
# @param $1    nft ip version type (ip or ipv6)
# @param $2    Table name to check
check_for_table()
{
	local __function_name="check_for_table"
	local ip_check=$1
	local table_check=$2

	local output=`nft list table $ip_check $table_check`
	local retval=$?
	if [ $retval -ne 0 ]; then
		echo "$__function_name: NFT does not have a required table for wan-manager"
		exit 1
	fi
}

# handle_term
# Process signterm signal to exit
handle_term()
{
	local __function_name="handle_term"
	for i in `pgrep -P $COMMAND_PID `
	do
		kill -9 $i
	done
}

# wait_for_change
# Use inotify to wait for specific files to change
#
# @param $1    Comma separated lsit of files to monitor
wait_for_change()
{
	local __function_name="wait_for_change"
	local files=$1

	inotifywait -r -qq -e create,modify $files
}

# is_offline
# Determine the interface stats offline status from stats generator.
#
# @param $1    Return value of true or false
# @param $2    Numeric interface id
# @param $3    IP family (ipv4 or ipv6)
is_offline()
{
	local __function_name="is_offline"
	local __return_offline=$1
	local id=$2
	local family=$3

	local __offline=true
	local interfaceId

	json_load_file /tmp/stats.json
	if json_is_a interfaces array ; then
			json_select interfaces
			json_get_keys interfaces
			for intf in $interfaces; do
					json_select $intf
					json_get_var interfaceId interfaceId
					if [ $id = $interfaceId ] ; then
							if [ $family = "ipv6" ] ; then
								json_get_var __offline offline6
							else
								json_get_var __offline offline
							fi
							if [ "$__offline" = "" ] ; then
								# If variable not found, consider it offline
								__offline=true
							fi
					fi
					json_select ..
			done
			json_select ..
	fi

	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: offline status for $id family: $family is $__offline"
	eval "$__return_offline=$__offline"
}

# get_wan_bandwidth
# Gather QOS bandwidth from settings.
# If not found, run speedtest on interface.
#
# Running speedtest can take between 20-30 seconds, so after running,
# store values in a file of the format $last_speedtest_download_$device=weight
# so that on subsequent wan-manager retarts, we can save time and use those.
#
# @param $1	   Return value of weight as a number
# @param $2    Numeric interface id
# @param $3    Short policy identifier
get_wan_bandwidth()
{
	local __function_name="get_wan_bandwidth"
	local __return_weight=$1
	local id=$2
	local policy=$3

	local __settingsWeight=0
	local network
	local interfaces
	local i
	local interfaceId

	json_load_file /etc/config/current.json
	json_select network
	json_select interfaces
	json_get_keys interfaces
	for i in $interfaces ; do
		json_select $i
		json_get_var interfaceId interfaceId
		if [ $id = $interfaceId ] ; then
			json_get_var __settingsWeight downloadKbps
		fi
		json_select ..
	done
	json_select ..
	json_select ..

	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: id=$id, policy=$policy, weight=$__settingsWeight"
	eval "$__return_weight=$__settingsWeight"
}

# get_static_weight
# Get the WAN weight from the settings file, per policy
#
# @param $1	   Return value of weight as a number
# @param $2    Short policy name
# @param $3    Numeric interface id
# !!! something to indicate this is from settings
get_static_weight()
{
	local __function_name="get_static_weight"
	local __return_weight=$1
	local policy=$2
	local id=$3

	local __weight=0
	local wan
	local policies
	local policyId
	local interfaces
	local i
	local interfaceId

	json_load_file /etc/config/current.json
	json_select wan
	json_select policies
	json_get_keys policies
	for p in $policies ; do
		json_select $p
		json_get_var policyId policyId
		policyIdString="policy-$policyId"
		if [ -z "${policyIdString##*$policy*}" ]; then
			# Substring match on short policy id to full policy id
			json_select interfaces
			json_get_keys interfaces
			for i in $interfaces ; do
				json_select $i
				json_get_var interfaceId interfaceId
				if [ $interfaceId -eq 0 ] ; then
					__weight=1
				elif [ $id = $interfaceId ] ; then
					json_get_var __weight weight
				fi
				json_select ..
			done
			json_select ..
		fi
		json_select ..
	done
	json_select ..
	json_select ..

	eval "$__return_weight=$__weight"
}

# get_stat
# Retrieve specific stats from the /tmp/stats.json file, per interface id
# 
# @param $1	   Return value of metric
# @param $2    Numeric interface id
# @param $3    Statistic name to look for (ie: ping, latency, etc.)
# @param $4    Metric name to look for (ie: 1_minute, 10_minute, etc.)
get_stat()
{
	local __function_name="get_stat"
	local __return_stat=$1
	local id=$2
	local stat_name=$3
	local metric_name=$4

	local stat_value=0
	local interfacves
	local interfaceId
	local name
	local metrics
	local metric
	local name

	json_load_file /tmp/stats.json
	if json_is_a interfaces array ; then
		json_select interfaces
		json_get_keys interfaces
		for intf in $interfaces; do
			json_select $intf
			json_get_var interfaceId interfaceId
			if [ $id = $interfaceId ] ; then
				json_select "stats"
				json_get_keys stats
				for stat in $stats; do
					json_select $stat
					json_get_vars name
					if [ $stat_name = $name ] ; then
						json_select "metrics"
						json_get_keys metrics
						for metric in $metrics; do
							json_select $metric
							json_get_vars name value
							if [ $metric_name = $name ] ; then
								stat_value=$(echo ${value%%.*})
							fi
							json_select ..
						done
						json_select ..
					fi
					json_select ..
				done
				json_select ..
			fi
			json_select ..
		done
		json_select ..
	fi

	eval "$__return_stat=$stat_value"
}

# is_wan_up_by_family
# Determine if wan is up by family.
#
# @param $1	   Return value of test
# @param $2    Short policy name
# @param $3    Numeric interface id
# @param $4    Ip family
is_wan_up_by_family()
{
	local __function_name="is_wan_up_by_family"
	local __is_wan_up_by_family=$1
	local policy=$2
	local id=$3
	local family=$4
	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: policy=$policy, id=$id, family=$family"

	local wan_path
	get_wan_path wan_path $policy $id $family

	local __up=false
	
	local __criteria_found=0
	local __down_found=0
	for file in $(find $wan_path -type f); do
		__criteria_found=$((__criteria_found + 1))
		grep -q down $file
		if [ $? -eq 0 ] ; then
			__down_found=1
		fi
	done
	__up=false
	if [ $__criteria_found -gt 0 ] && [ $__down_found -eq 0 ] ; then
		# Only up if we found at least one criteria and no "down" statuses.
		__up=true
	fi

	eval "$__is_wan_up_by_family=$__up"

}

# is_wan_up
# Search through the policy directory to find out if specific WANs are currently down
#
# @param $1	   Return value of test
# @param $2    Short policy name
# @param $3    Numeric interface id
is_wan_up()
{
	local __function_name="is_wan_up"
	local __return_wan_up=$1
	local policy=$2
	local id=$3

	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: policy=$policy, id=$id"

	local __up
	local __ipv4_up
	local __ipv6_up
	is_wan_up_by_family __ipv4_up $policy $id ipv4
	is_wan_up_by_family __ipv6_up $policy $id ipv6

	if [ "$__ipv4_up" = "true" ] || [ "$__ipv6_up" = "true" ] ; then
		__up=true
	fi

	eval "$__return_wan_up=$__up"
}

# disable_policy
# Disable specific policies when a wan is down
#
# @param $1    Short name of policy to disable
# @param $2    Space separated numeric ids of WANs involved
disable_policy()
{
	local __function_name="disable_policy"
	local policy=$1
	local wans=$2

	TMPFILE=`mktemp -t $policy-changeset.XXXXXX`

	for wan in $wans ; do
		echo flush set ip wan-routing wan-$wan-table >> $TMPFILE
		echo flush set ip6 wan-routing wan-$wan-table >> $TMPFILE
	done

	echo flush chain ip wan-routing route-to-$policy >> $TMPFILE
	echo flush set ip wan-routing $policy-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy return comment \"policy disabled\" >> $TMPFILE

	echo flush chain ip6 wan-routing route-to-$policy >> $TMPFILE
	echo flush set ip6 wan-routing $policy-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy return comment \"policy disabled\" >> $TMPFILE

	nft -f $TMPFILE
	retval=$?
	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: $policy All Wans:$wans Retval: $retval"
	while [ $retval -ne 0 ] ; do
		nft -f $TMPFILE
		retval=$?
		log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: nft -f Failed to disable policy: $policy All Wans:$wans Retval: $retval, trying again..."
	done
	rm $TMPFILE
}

# get_policy_wans_and_up_wans
# Determine which wans and policy wans are available based on wans associated with the policy directories, and all wans
#
# @param $1    Return space separatd list of interfaceIds in policy
# @param $2    Return space separatd list of interfaceIds in policy that are up
# @param $3    Policy id
get_policy_wans_and_up_wans() 
{
	local __function_name="get_policy_wans_and_up_wans"
	local __return_policy_wans=$1
	local __return_up_wans=$2
	local policy=$3

	local __policy_wans
	local __up_wans

	local d
	local policy_dir
	local fileName
	local id
	get_policy_path policy_dir $policy

	for d in $policy_dir/* ; do
		log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: found file: $d"
		fileName=$(echo ${d##*/})

		# Ignore the status files in the policy directory
		if [ $fileName == "status" ] ; then
			log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: skipping file: $d"
			continue
		fi

		# $(d##*/) is extracting the last directory in the string path cut on 2nd field to get the numerical wan ID
		# ex:
		# assume d = /tmp/wan_status/policy-822f5c96-e04b-4248-aea4-7cbd5d4a8af5/wan-2
		# then id = 2
		id=$(echo $fileName | cut -d '-' -f 2)	
		__policy_wans="$__policy_wans $id"
		local wan_up
		is_wan_up wan_up $policy $id
		# if is_wan_up $policy $id; then
		if [ "$wan_up" = "true" ] ; then
			__up_wans="$__up_wans $id"
		fi
	done

	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: policy_wans=$__policy_wans wans=$__wans"
	eval "$__return_policy_wans=\"$__policy_wans\""
	eval "$__return_up_wans=\"$__up_wans\""
}

# jump_policy
# Insert jump rules for specific policies
#
# @param $1    Policy associated with the chain
# @param $2    Interface id of the wan to use
# @param $3    The wans included in this policy
jump_policy()
{
	local __function_name="jump_policy"
	local policy=$1
	local id=$2
	local wans=$3

	TMPFILE=`mktemp -t $policy-changeset.XXXXXX`

	for wan in $wans ; do
		echo flush set ip wan-routing wan-$wan-table >> $TMPFILE
		echo flush set ip6 wan-routing wan-$wan-table >> $TMPFILE
	done

	echo flush chain ip wan-routing route-to-$policy >> $TMPFILE
	echo flush set ip wan-routing $policy-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy set update ip saddr . ip daddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy set update ip daddr . ip saddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy jump update-rule-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy dict sessions ct id wan_policy long_string set $policy >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy jump mark-for-wan-$id >> $TMPFILE

	echo flush chain ip6 wan-routing route-to-$policy >> $TMPFILE
	echo flush set ip6 wan-routing $policy-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy set update ip6 saddr . ip6 daddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy set update ip6 daddr . ip6 saddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy jump update-rule-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy dict sessions ct id wan_policy long_string set $policy >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy jump mark-for-wan-$id >> $TMPFILE

	nft -f $TMPFILE
	retval=$?
	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: updating jump_policy for policy:$policy mark for WAN:$id All WANs: $wans; retval: $retval"
	while [ $retval -ne 0 ] ; do
		nft -f $TMPFILE
		retval=$?
		log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: nft -f failed during jump_policy for policy:$policy mark for WAN:$id All WANs: $wans; retval: $retval, trying again..."
	done
	rm $TMPFILE
}

# balance_policy
# Insert rules for balance policy types
#
# @param $1    Policy
# @param $2    Wans associated with this policy
# @param $3    Total weight of all wans in the policy
# @param $4    Generated balance string used in the vmap decision
balance_policy()
{
	local __function_name="balance_policy"
	local policy=$1
	local wans=$2
	local total_weight=$3
	local balance_string=$4

	TMPFILE=`mktemp -t $policy-changeset.XXXXXX`

	for wan in $wans ; do
		echo flush set ip wan-routing wan-$wan-table >> $TMPFILE
		echo flush set ip6 wan-routing wan-$wan-table >> $TMPFILE
	done

	echo flush chain ip wan-routing route-to-$policy >> $TMPFILE
	echo flush set ip wan-routing $policy-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy set update ip saddr . ip daddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy set update ip daddr . ip saddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy jump update-rule-table >> $TMPFILE
	echo add rule ip wan-routing route-to-$policy dict sessions ct id wan_policy long_string set $policy >> $TMPFILE
	echo add ip wan-routing route-to-$policy numgen random mod $total_weight vmap { $balance_string } >> $TMPFILE

	echo flush chain ip6 wan-routing route-to-$policy >> $TMPFILE
	echo flush set ip6 wan-routing $policy-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy set update ip6 saddr . ip6 daddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy set update ip6 daddr . ip6 saddr timeout 1m @$policy-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy jump update-rule-table >> $TMPFILE
	echo add rule ip6 wan-routing route-to-$policy dict sessions ct id wan_policy long_string set $policy >> $TMPFILE
	echo add ip6 wan-routing route-to-$policy numgen random mod $total_weight vmap { $balance_string } >> $TMPFILE

	nft -f $TMPFILE
	retval=$?
	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: running balance policy:$policy All Wans:$wans total_weight:$total_weight balance string:$balance_string Retval: $retval"
	while [ $retval -ne 0 ] ; do
		nft -f $TMPFILE
		retval=$?
		log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: nft -f failed while running balance policy:$policy All Wans:$wans total_weight:$total_weight balance string:$balance_string Retval: $retval, trying again..."
	done
	rm $TMPFILE
}

# get_openwrt_interface_name
# From the specified interfaceId, return the OpenWrt name.
# NOTE: This uses the same logic as network_util.get_interface_name()
#
# @param $1    Return value of of field.
# @param $2	   Interface id
# @param $3	   Family
get_openwrt_interface_name(){
	local __function_name="settings_get_interface_field"
	local __return_name=$1
	local interface_id=$2
	local family=$3

	local network
	local interfaces
	local i
	local interfaceId
	local __name=""
	local __type=""

	json_load_file /etc/config/current.json
	json_select network
	json_select interfaces
	json_get_keys interfaces
	for i in $interfaces ; do
		json_select $i
		json_get_var interfaceId interfaceId
		if [ $interface_id = $interfaceId ] ; then
			json_get_var __name name
			json_get_var __type type
		fi
		json_select ..
	done
	
	if [ "$__name" != "" ] && [ "$__type" != "" ] ; then
		if [ "$__type" != "IPSEC"  ] && [ "$__type" != "OPENVPN" ] && [ "$__type" != "WIREGUARD" ] && [ "$__type" != "WWAN"  ] ; then
			if [ "$family" = "ipv6" ] ; then
				__name="${__name}6"
			else
				__name="${__name}4"
			fi
		fi
	fi

	eval "$__return_name=$__name"

}

# settings_get_ipsec_remote_gateway
# Get ipsec remote gateway address
#
# @param $1    Return value of gateway IP address
# @param $2    Interface Id to match
# @param $3	   Return value of metric
settings_get_ipsec_remote_gateway(){
	local __return_remoteGateway=$1
	local id=$2

	local network
	local interfaces
	local i
	local interfaceId
	local type
	local ipsec
	local remote
	local __remoteGateway

	json_load_file /etc/config/current.json
	json_select network
	json_select interfaces
	json_get_keys interfaces
	for i in $interfaces ; do
		json_select $i
		json_get_var interfaceId interfaceId
		if [ $id = $interfaceId ] ; then
			json_get_type type ipsec
			if [ "$type" = "" ] ; then
				# Not an ipsec interface
				json_select ..
				continue
			fi
			json_select ipsec
			json_select remote
			json_get_var __remoteGateway gateway
			break
		fi
		json_select ..
	done

	eval "$__return_remoteGateway=$__remoteGateway"
}

##
## Criteria
##

# up
# Determine which interfaces should be used in a policy calculationbased on connectivity
#
# @param $1    Policy id
# @param $2    Numeric interface id
# @param $3    OpenWrt interface name 
# @param $4    Ip family of the interface
criteria_up()
{
	local __function_name="criteria_up"
	local policy=$1
	local interfaceId=$2
	local interface=$3
	local family=$4
	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: policy=$policy, interfaceId=$interfaceId, interface=$interface, family=$family"

	local wan_path
	get_wan_path wan_path $policy $interfaceId $family
	local status_file="${wan_path}/${__function_name}"

	status="init"
	if [ -f $status_file ] ; then
		status=$(head -n 1 $status_file)
	fi

	network_flush_cache
	local offline
	is_offline offline $interfaceId $family
	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: $interface and $status_file current status is $status, offline=$offline"
	if network_is_up $interface  && [ "$offline" = "false" ]; then
		new_status="up"
	else
		new_status="down"
	fi

	log_state="status"
	if [ "$new_status" != "$status" ] ; then
		log_state="change"
		echo $new_status > $status_file
	fi

	log_status_message "$log_state" "$__function_name:" \
		"policy=$policy, interface=${interfaceId}/$interface/$family, status=$status->$new_status" \
		"policy=$policy, interface=${interfaceId}/$interface/$family, status=$new_status"
}

# attribute
# Insert policy rules associated to a wan with specific attributes.
# IMPORTANT: At this time, these attribute values are pre-calculated!  We just write the result
#
# @param $1    Policy id
# @param $2    Numeric policy id
# @param $3    Interface name
# @param $4    IP family
# @param $5    Attribtute key
# @param $6    Attribute value to match
# @param $7    Status to set (up or down)
criteria_attribute()
{
	local __function_name="criteria_attribute"
	local policy=$1
	local interfaceId=$2
	local interface=$3
	local family=$4
	local key=$5
	local value=$6
	local new_status=$7

	local wan_path
	get_wan_path wan_path $policy $interfaceId $family
	local status_file="${wan_path}/${__function_name}_${key}_${value}"
	status="init"
	if [ -f $status_file ] ; then
		status=$(head -n 1 $status_file)
	fi

	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: policy=$policy, interfaceId=$interfaceId, interface=$interface, attribute=$attribute, family=$family, key=$key, value=$value, new_status=$new_status"

	log_state="status"
	if [ "$new_status" != "$status" ] ; then
		log_state="change"
		echo $new_status > $status_file
	fi

	log_status_message "$log_state" "$__function_name:" \
		"policy=$policy, interface=$interfaceId/$interface/$family, attribute=$key,$value, status=$status->$new_status" \
		"policy=$policy, interface=$interfaceId/$interface/$family, attribute=$key,$value, status=$new_status"

}

# metric
# Insert policy rules that check specific metrics against interfaces
#
# @param $1    Policy id
# @param $2    Numeric interface id
# @param $3    Interface name
# @param $4    Ip family
# @param $5    Stat name to use in the metric calculation
# @param $6    Metric name to use in the metric calculation
# @param $7    Operator to use in the metric calculation
# @param $8    Metric value to test against in the metric calculation
criteria_metric()
{
	local __function_name="criteria_metric"
	local policy=$1
	local interfaceId=$2
	local interface=$3
	local family=$4
	local stat_name=$5
	local metric_name=$6
	local operator=$7
	local val=$8

	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: policy=$policy, interfaceId=$interfaceId, interface=$interface, family=$family, stat_name=$stat_name, metric_name=$metric_name, operator=$operator, val=$val"

	local test=-1
	local wan_path
	get_wan_path wan_path $policy $interfaceId $family
	status_file="$wan_path/${__function_name}_${stat_name}_${metric_name}_${operator}_${val}"	
	status="init"
	if [ -f $status_file ] ; then
		status=$(head -n 1 $status_file)
	fi

	# get_stat test $interfaceId $stat_name $metric_name
	get_stat test $interfaceId $stat_name $metric_name

	# Important assumption here!!!
	# VPNs and some other interfaces sometimes report a latency of 0
	# Setting the test results to -1 will allow the logic below to skip this interface during the WAN checks
	if [ $stat_name = "latency" ] && [ $test = 0 ] ; then
		test=-1
	fi

	local new_status="down"
	if [ $test -ne -1 ] ; then
		case $operator in
			le)
				if [ $test -le $val ] ; then
					new_status="up"
				fi
				;;
			lt)
				if [ $test -lt $val ] ; then
					new_status="up"
				fi
				;;
			ge)
				if [ $test -ge $val ] ; then
					new_status="up"
				fi
				;;
			gt)
				if [ $test -gt $val ] ; then
					new_status="up"
				fi
				;;
		esac
	fi

	log_state="status"
	if [ "$new_status" != "$status" ] ; then
		log_state="change"
		echo $new_status > $status_file
	fi

	log_status_message "$log_state" "$__function_name:" \
		"policy=$policy, interface=$interfaceId/$interface/$family, statistic=$stat_name/$metric_name/$operator/$val, status=$status->$new_status" \
		"policy=$policy, interfaceId=$interface/$interface/$family, statistic=$stat_name/$metric_name/$operator/$val, status=$new_status"
}

# connectivity
# Used to insert policy rules for specific connectivity testing types or methods on the wan
#
# @param $1    Policy id
# @param $2    Numeric interface id
# @param $3    Interface name
# @param $4    Ip family
# @param $5    Criteria type to use (ping, http, arp, dns)
# @param $6    Interval of when to run the tests
# @param $7    Timeout of when to fail the test
# @param $8    Failure threshold of when to fail the tests
# @param $9    Fost to run the connectivity tests against
criteria_connectivity()
{
	local __function_name="criteria_connectivity"
	local policy=$1
	local interfaceId=$2
	local interface=$3
	local family=$4
	local criteria=$5
	local interval=$6
	local timeout=$7
	local threshold=$8
	local host=$9

	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: policy=$policy, interfaceId=$interfaceId, interface=$interface, family=$family, critera=$critera, interval=$interval, timeout=$timeout, threshold=$threshold, host=$host"

	local device
	local ip_address
	local dns_server
	local gw
	local status
	local new_status
	local offline

	local result0=1
	local result1=1
	local result2=1
	local result3=1
	local result4=1
	local result5=1
	local result6=1
	local result7=1
	local result8=1
	local result9=1

	local wan_path
	get_wan_path wan_path $policy $interfaceId $family
	status_file="$wan_path/${__function_name}_${criteria}_${host}_${interval}_${timeout}_${threshold}"

	## If the status_file already exists, lets see what the previous status was
	local new_status="down"
	local status="init"
	if [ -f $status_file ] ; then
		status=$(head -n 1 $status_file)
	fi

	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: $policy and $status_file current status is $status"

	for i in $(seq 0 9) ; do
		network_flush_cache
		is_offline offline $interfaceId $family
		if [ "$offline" = "true" ] ; then
			# No point in continuing if interface is down
			new_status="down"
			break
		fi
		log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: test interface=$interface, offline=$offline, interval running sequence i=$i"
		if network_is_up $interface  && [ "$offline" = "false" ]; then
			log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: testing up and online interface=$interface"

			network_get_device device $interface
			network_get_ipaddr ip_address $interface
			network_get_dnsserver dns_server $interface
			network_get_gateway gw $interface

			case $criteria in
				ping)
					if [ "$family" = "ipv4" ] ; then
						ping -I $device -w $timeout -W $timeout -c 1 $host > /dev/null && let result"$i"=1 || let result"$i"=0
					fi
					;;
				arp)
					if [ "$family" = "ipv4" ] ; then
						arping -s $ip_address -I $device -c 1 $gw > /dev/null && let result"$i"=1 || let result"$i"=0
					fi
					;;
				dns)
					if [ "$family" = "ipv4" ] ; then
						dig -b $ip_address +tries=3 +timeout=$timeout $dns_server $host > /dev/null && let result"$i"=1 || let result"$i"=0
					fi
					;;
				http)
					if [ "$family" = "ipv4" ] ; then
						wget --no-check-certificate --bind-address=$ip_address --header="Wan-Failover-Flag: true" --tries=3 -O /dev/null $host 2> /dev/null && let result"$i"=1 || let result"$i"=0
					fi
					;;
				*)
					echo "Unknown test $criteria"
					let result"$i"=0
					;;
			esac

			# While it may seem like we should be calculating this outside the loop,
			# We want to do it inside so if we meet our threshold of failures, we
			# can stop immediately.
			count=0
			for i in $(seq 0 9) ; do
				eval "temp=\"\$result$i\""
				if [ $temp -eq 0 ] ; then
					let count++
				fi
			done
			if [ $count -ge $threshold ] ; then
				log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: reached failure threshold"
				new_status="down"
				break
			else
				new_status="up"
			fi
		fi
	done

	log_state="status"
	if [ "$new_status" != "$status" ] ; then
		log_state="change"
		echo $new_status > $status_file
	fi

	log_status_message "$log_state" "$__function_name:" \
		"policy=$policy, interface=$interfaceId/$interface/$family, test=$criteria/$interval/$timeout/$threshold/$host, status=$status->$new_status" \
		"policy=$policy, interface=$interfaceId/$interface/$family, test=$criteria/$interval/$timeout/$threshold/$host, status=$new_status"
}

##
## Policies
##

# specific_wan
# Send traffic to a specific wan policy
#
# @param $1    Policy id
# @param $2    Interface id
policy_specific_wan()
{
	local __function_name="policy_specific_wan"
	local policy=$1
	local id=$2

	# log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: policy=$policy wan=$wan result:$result status:$status"

	local policy_path
	get_policy_path policy_path $policy
	status_file="$policy_path/status"

	status="init"
	if [ -f $status_file ] ; then
		. $status_file
	fi

	local wan_up
	is_wan_up wan_up $policy $id
	if [ "$wan_up" = "true" ] ; then
		new_status="up"
	else
		new_status="down"
	fi

	local log_state="status"
	if [ "$new_status" != "$status" ] ; then
		local log_state="change"
		echo "status=$new_status" > $status_file
		if [ $new_status = "up" ] ; then
			jump_policy $policy $id "$id"
		else
			disable_policy $policy "$id"
		fi
	fi
	log_status_message "$log_state" "$__function_name:" \
		"policy=$policy, status=$status->$new_status" \
		"policy=$policy, status=$new_status"

}

# best_of
# Insert route rules for wans that fall into a specific best_of metric
#
# @param $1    Policy identifier
# @param $2    Stat name to test with (e.g.,latency)
# @param $3    Metric name to test with (e.g.,1_minute)
# @param $4    Operator to test with (e.g.,le)
policy_best_of()
{
	local __function_name="policy_best_of"
	local policy=$1
	local stat_name=$2
	local metric_name=$3
	local operator=$4

	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: policy=$policy, stat_name=$stat_name, metric_name=$metric_name, operator=$operator"

	local policy_path
	get_policy_path policy_path $policy
	status_file="$policy_path/status"

	# Get current status
	local status="init"
	local current_best_wan=-1
	if [ -f $status_file ] ; then
		. $status_file
	fi

	local policy_wans
	local wans
	get_policy_wans_and_up_wans policy_wans wans $policy

	local best_wan=-1
	local best_stat=-1
	local stat
	for wan in $wans ; do
		get_stat stat $wan $stat_name $metric_name

		log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: wan=$wan, stat=$stat comparing best_wan=$best_wan, best_stat=$best_stat"

		if [ $stat_name = "latency" ] ; then
			if [ "$stat" = 0 ] || [ "$stat" = -1 ] ; then
				# NOTE: A latency of 0  means 100% pakcet loss, so ignore during best_of calculations
				continue
			fi
		fi

		if [ $best_wan -eq -1 ] ; then
			# Initialize
			best_wan=$wan
			best_stat=$stat
		else
			case $operator in
				le)
					if [ $stat -le $best_stat ] ; then
						best_wan=$wan
						best_stat=$stat
					fi
					;;
				lt)
					if [ $stat -lt $best_stat ] ; then
						best_wan=$wan
						best_stat=$stat
					fi
					;;
				ge)
					if [ $stat -ge $best_stat ] ; then
						best_wan=$wan
						best_stat=$stat
					fi
					;;
				gt)
					if [ $stat -gt $best_stat ] ; then
						best_wan=$wan
						best_stat=$stat
					fi
					;;
			esac
		fi
	done

	local new_status=$status
	local new_best_wan=$current_best_wan
	if [ $best_wan -eq -1 ] ; then
		new_status="down"
	else
		new_status="up"
	fi
	new_best_wan=$best_wan

	local log_state="status"
	if [ "$new_status" != "$status" ] || [ ! $current_best_wan -eq $new_best_wan ] ; then
		log_state="change"
		echo "status=$new_status" > $status_file
		echo "current_best_wan=$new_best_wan" >> $status_file
		if [ "$new_status" = "up" ] ; then
			jump_policy $policy $new_best_wan "$policy_wans"
		else
			disable_policy $policy "$policy_wans"
		fi
	fi
	log_status_message "$log_state" "$__function_name:" \
		"policy=$policy, status=$status->$new_status, best_wan=$current_best_wan->$new_best_wan" \
		"policy=$policy, status=$new_status, best_wan=$new_best_wan"

}

# ipsec_vpn_best_wan
# Change ipsec connection to best WAN
#
# @param $1    Policy identifier
# @param $2    Numeric interface id
# @param $3    Interface name
# @param $4    Ip family for interface
policy_best_of_ipsec_vpn()
{
	local __function_name="policy_best_of_ipsec_vpn"
	local policy=$1
	local interfaceId=$2
	local interfaceName=$3
	local family=$4

	local remoteGateway
	settings_get_ipsec_remote_gateway remoteGateway $interfaceId
	if [ "$remoteGateway" = "" ] ; then
		log_message $LOG_MESSAGE_PRIORITY_ANY "$__function_name: policy=$policy, interfaceId=$interfaceId, unable to get remote gateway address"
		return 
	fi
	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: policy=$policy, interfaceId=$interfaceId, interfaceName=$interfaceName, family=$family, remoteGateway=$remoteGateway"	

	local policy_path
	get_policy_path policy_path $policy
	status_file="$policy_path/status"

	local status="init"
	local current_best_wan=-1
	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: getting policy=$policy reading $status_file"
	if [ -f $status_file ] ; then
		. $status_file
	fi

	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: policy=$policy, status=$status, current_best_wan=$current_best_wan"	
	if [ "$status" != "up" ] || [ $current_best_wan -eq -1 ]; then
		# No policy status
		return
	fi

	local current_best_interface_name
	get_openwrt_interface_name current_best_interface_name $current_best_wan $family
	network_get_ipaddr ip_address $current_best_interface_name
	network_get_device interface_device $current_best_interface_name

	# Look at current left and if same, continue
	current_left_address=$(ip xfrm policy | grep "dst $remoteGateway" | head -1 | cut -d' ' -f3)
    if [ "$current_left_address" = "dst" ] || [ "$current_left_address" = "" ] ; then
		# No found in policies
		log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: unable to find appropriate remoteGateway=$remoteGateway"
        return
    fi

	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: current_best_interface_name=$current_best_interface_name, interface_device=$interface_device, ip_address=$ip_address, current_left_address=$current_left_address"
	log_state="status"
	if [ "$ip_address" != "$current_left_address" ]; then
		#
		# WAN changed.
		#
		log_state="change"
		# log_message $LOG_MESSAGE_PRIORITY_ANY "$__function_name: changed policy=$policy. switching to interface_device=$interface_device, left ip_address=$current_left_address -> $ip_address"

		# Stop ipsec
		ipsec stop 2>/dev/null
		# Flush current state
		ip xfrm state flush

		# Walk through WANs associated with policies to get identifier into WAN priority tables.
		# Delete WAN priority routes.
		local del_interface

		local policy_wans
		local wans
		get_policy_wans_and_up_wans policy_wans wans $policy

		log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: CHANGE ip route change table wan.priority $remoteGateway/32 src $ip_address dev $interface_device"
		ip route change table wan.priority $remoteGateway/32 src $ip_address dev $interface_device

		# Change IPSEC tunnel vti interface's local WAN address and device.
		network_get_device ipsec_device $interfaceName
		log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: CHANGE tunnel ipsec_device=$ipsec_device to local address to ip_address=$ip_address, interface_device=$interface_device"
		ip tunnel change $ipsec_device local $ip_address dev $interface_device

		# Update live ipsec
		ipsec_live_name=/var/ipsec/ipsec.conf
		ipsec_temp_name=$(mktemp /tmp/ipsec.confXXXXXX)
		# Looking for our remote gateway, modify the left side to reflect the new WAN IP address.
		awk '/right='$remoteGateway'/{sub(/left=.*/, "left='$ip_address'", last)} NR>1{print last} {last=$0} END {print last}' \
			$ipsec_live_name > $ipsec_temp_name \
			&& mv $ipsec_temp_name $ipsec_live_name

		# Bring IPSec back up
		ipsec restart 2>/dev/null

		# NOTE: Yes, stopping all of IPSec and bringing it back up seems extreme as it will
		# force a restart to all non-effected tunnels.  However, this seems to be the most
		# reliable way to perform this kind of failover change.
	fi
	log_status_message "$log_state" "$__function_name:" \
		"policy=$policy, interface_device=$interface_device, left ip_address=$current_left_address->$ip_address" \
		"policy=$policy, current_best_interface_name=$current_best_interface_name, left ip_address$ip_address"

}

# balance
# Balance a group of wans using a specific balancing algorithm
#
# @param $1    Policy id
# @param $2    Balance algorithm to use (ie: LATENCY, WEIGHTED, AVAILABLE_BANDWIDTH)
policy_balance()
{
	local __function_name="policy_balance"
	local policy=$1
	local algorithm=$2

	local policy_path
	get_policy_path policy_path $policy
	status_file="$policy_path/status"

	status="init"
	balance_string=""
	if [ -f $status_file ] ; then
		. $status_file
	fi

	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: $policy and $status_file current status is $status"

	local total_weight=0
	local new_balance_string=""

	local policy_wans
	local wans
	get_policy_wans_and_up_wans policy_wans wans $policy

	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: wans: $wans policy_wans: $policy_wans"

	total_latency=0
	local latency
	local weight
	if [ $algorithm = "LATENCY" ] ; then
		for wan in $wans ; do
			get_stat latency $wan "latency" "1_minute"
			total_latency=$((total_latency + $latency))
		done
	fi
	for wan in $wans ; do
		if [ $algorithm = "WEIGHTED" ] ; then
			get_static_weight weight $policy $wan
		elif [ $algorithm = "LATENCY" ] ; then
			get_stat weight $wan "latency" "1_minute"
			weight=$(($total_latency - $weight))
			if [ $weight -eq 0 ] ; then
				weight=100
			fi
		elif [ $algorithm = "AVAILABLE_BANDWIDTH" ] ; then
			get_stat weight $wan "available_bandwidth" "1_minute"
		elif [ $algorithm = "BANDWIDTH" ] ; then
			get_wan_bandwidth weight $wan
		fi

		if [ $weight -eq 0 ] ; then
			continue
		fi

		if [ $total_weight -ne 0 ] ; then
			new_balance_string="$new_balance_string, "
		fi

		range_end=$(($weight + $total_weight - 1))
		if [ $total_weight -eq $range_end ] ; then
			new_balance_string="$new_balance_string$total_weight : jump mark-for-wan-$wan"
		else
			new_balance_string="$new_balance_string$total_weight-$range_end : jump mark-for-wan-$wan"
		fi
		total_weight=$((total_weight + $weight))
	done

	if [ "$new_balance_string" = "" ] ; then
		new_status="down"
	else
		new_status="up"
	fi

	local log_state="status"
	if [ "$new_status" != "$status" ] || [ "$balance_string" != "$new_balance_string" ] ; then
		local log_state="change"
		echo "status=$new_status" > $status_file
		echo "balance_string=\"$new_balance_string\"" >> $status_file
		if [ "$new_status" = "down" ] ; then
			if [ $status != "down" ] ; then
				disable_policy $policy "$policy_wans"
			fi
		else
			if [ ! $status = "up" ] || [ "$new_balance_string" != "$balance_string" ] ; then
				balance_policy $policy "$policy_wans" $total_weight "$new_balance_string"
			fi
		fi
	fi
	log_status_message "$log_state" "$__function_name:" \
		"policy=$policy, status=$status->$new_status" \
		"policy=$policy, status=$status" \
		"balance_string='$balance_string' -> '$new_balance_string'"
}

##
## Main 
##
__function_name="main"

# Check for wan-routing tables before continuing
check_for_table ip wan-routing
check_for_table ip6 wan-routing

if [ "$DEBUG" = "true" ] || [ "$INTERACTIVE" == "true" ] ; then
	log_message $LOG_MESSAGE_PRIORITY_ANY "$__function_name: COMMAND_NAME=$COMMAND_NAME"
	log_message $LOG_MESSAGE_PRIORITY_ANY "$__function_name: COMMAND_PID=$COMMAND_PID"
	log_message $LOG_MESSAGE_PRIORITY_ANY "$__function_name: INTERACTIVE=$INTERACTIVE"
	log_message $LOG_MESSAGE_PRIORITY_ANY "$__function_name: DEBUG=$DEBUG"
	log_message $LOG_MESSAGE_PRIORITY_ANY "$__function_name: LOG_WATCH=$WATCH"
fi

if [ "$INTERACTIVE" = "false" ] ; then
	# Create term handler and run the handle_term callback
	trap 'handle_term' TERM INT
else
	# If we're in interactive (developer) mode we don't want the system daemon process running
	for pid in `pgrep -f $COMMAND_NAME `; do
		if [ "$pid" = "$COMMAND_PID" ]; then
			# Ignore ourselves
			continue
		fi
		log_message $LOG_MESSAGE_PRIORITY_ANY "$__function_name: killing other running process $pid"
		kill -9 $pid
	done
fi
log_message $LOG_MESSAGE_PRIORITY_ANY "$__function_name: started, pid=$COMMAND_PID"

# Cleanup old wan_status files
rm -rf ${WAN_MANAGER_STATUS_PATH}/*

# Wait for stats.json to change, and then run every policy once (vs having each policy wait for change every time)
while [ 1 ] ; do
	wait_for_change /tmp/stats.json
	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: --- begin wan_manager config"
	. /etc/config/wan_manager
	check_allow_log_update
	log_message $LOG_MESSAGE_PRIORITY_DEBUG "$__function_name: ---   end wan_manager config"
done

# Exit, wait for us to finish
for i in `pgrep -P COMMAND_PID `
do
	wait $i
done
log_message $LOG_MESSAGE_PRIORITY_ANY "$__function_name: exit, pid=$COMMAND_PID"
